# Напишите программу, доказывающую или проверяющую,
#что для множества натуральных чисел выполняется равенство:
#1+2+...+n = n(n+1)/2, где n — любое натуральное число.

import cProfile

# вариант 2 - через цикл


def theory(n):
    #Правая часть:
    k = n * (n + 1) / 2

    # Левая часть:
    p = 0

    for i in range (1, (n+1)):
        p += i         
   
    return (k == p)

#print(theory(20))
#cProfile.run('theory(1000000)')

#   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
#        1    0.000    0.000    0.000    0.000 <string>:1(<module>)      - 100
#        1    0.001    0.001    0.001    0.001 hw42.py:10(theory)       - 1 000        
#        1    0.006    0.006    0.006    0.006 hw42.py:10(theory)       - 10 000
#        1    0.267    0.267    0.267    0.267 hw42.py:10(theory)       - 1 000 000


#2" "hw42.theory(100)"
#100 loops, best of 5: 14.8 usec per loop

#2" "hw42.theory(1000)"
#100 loops, best of 5: 212 usec per loop

#2" "hw42.theory(10000)"
#100 loops, best of 5: 2.35 msec per loop

#Вывод: сложность алгоритма, скорее, O(n).
#При увеличении входного параметра время работы увеличивается примерно линейно.
#Количество вызовов функции 1. Нет ограничения вх. параметра в 987, как в рекурсии.
#Скорость работы алгоритма на 1000 в 2,5 раза выше, чем в алгоритме с рекурсией на 900.
